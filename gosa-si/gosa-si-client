#!/usr/bin/perl
#*********************************************************************
#
# gosa-si-client -- client for the gosa-si-server
#
# (c) 2007-2009 by Andreas Rettenberger <rettenberger@gonicus.de>
# (c) 2008-2010 by Cajus Pollmeier <pollmeier@gonicus.de>
# (c) 2008-2009 by Jan Wenzel <wenzel@gonicus.de>
# (c) 2010 by Benoit Mortier <benoit.mortier@opensides.be>
#
#*********************************************************************

=head1 NAME

gosa-si-client - Client for GOsa support infrastructure

=head1 SYNOPSIS

gosa-si-client [-hvf] [-c config]

=head1 OPTIONS

B<-h>, B<--help>
    print out this help message

B<-v>, B<--verbose>
    be verbose (multiple v's will increase verbosity) 
    -v          ERROR level
    -vvv        WARNING  + ERROR level
    -vvvvv      INFO + WARNING level
    -vvvvvvv    DEBUG + INFO level
    -vvvvvvvvv  in and out going xml messages will be displayed

B<-f>, B<--foreground> 
    foregroud, process will not be forked to background

B<-c> I<file>, B<--config=>I<file>
    configuration file, default F</etc/gosa-si/client.conf>

B<-x> <dump>
     dump configuration to stdout
     ( 1 = current, 2 = default )

=head1 DESCRIPTION

B<gosa-si-client> belongs to the support infrastructure of GOsa. 
The client registrates at a GOsa-SI-server and accepts messages from it. 
Each message is related to a working instruction which will be executed on the client. 
Depending on the message an answer can be send back to the server.

=head1 BUGS 

Please report any bugs, or post any suggestions, to the GOsa mailing list <gosa-devel@oss.gonicus.de> or to <https://oss.gonicus.de/labs/gosa>


=head1 LICENCE AND COPYRIGHT

This code is part of GOsa (L<http://www.gosa-project.org>)

Copyright (C) 2003-2010 GONICUS GmbH

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

=cut

use strict;
use warnings;

use Getopt::Long;
use Config::IniFiles;
use Time::HiRes qw( gettimeofday );
use IO::Socket::INET;
use NetAddr::IP;
use Crypt::Rijndael;
use Digest::MD5  qw(md5_hex md5 md5_base64);
use MIME::Base64;
use XML::Simple;
use File::Basename;
use File::Spec;
use File::Pid;
use Net::ARP;
use GOsaSI::GosaSupportDaemon;

use POE qw(Component::Server::TCP Wheel::FollowTail Wheel::Run);
use Fcntl;
use POSIX;

# Workaround: need pure perl to make it work with UTF-8 :-(
$XML::Simple::PREFERRED_PARSER= "XML::SAX::PurePerl";

my $client_version = '$HeadURL$:$Rev$';

my $client_headURL;
my $client_revision;
my $client_status;
my $event_dir = "/usr/lib/gosa-si/client/events";
use lib "/usr/lib/gosa-si/client/events";

my (%cfg_defaults, $foreground, $pid_file, $procid, $pid, $log_file, $fai_logpath);
my ($server_ip, $server_port, $server_timeout, $server_domain, $server_key_lifetime);
my ($client_port, $ldap_enabled, $ldap_config, $pam_config, $nss_config);
my ($root_uid, $adm_gid);
my $xml;
my $event_hash;
my $default_server_key;
my @servers;
my $gotoHardwareChecksum;
my $system_com;
my $servers_string;

my $client_status_hash = { 'developmental'=>'revision', 'stable'=>'release'};

# globalise variables which are used in imported events
our $global_kernel;
our $cfg_file;
our $opts_file;
our $server_address;
our $client_address;
our $client_ip;
our $client_mac_address;
our $client_dnsname;
our $client_force_hostname;
our $server_key;
our $terminal_server_hash;
our $opts_dnslookup;
our $verbose= 0;

# where is the config stored by default and his name
our $config = '/etc/gosa-si/client.conf';

# by default dumping of config is undefined
our $dump_config = undef;

# default variables
my $REGISTERED = 0;

# path to fifo for non-gosa-si-client messages to gosa-si-server
my $fai_com_fifo = "/var/run/gosa-si/gosa-si-client.socket";
my $system_com_fifo = "/var/run/gosa-si/gosa-si-client-system-com.socket";
my %files_to_watch = (fai_fifo => $fai_com_fifo, system_fifo => $system_com_fifo); 

# in function register_at_gosa_si_server, after which period of seconds a new registration should be tried if a registration was not successful until now
my $delay_set_time = 10;
#our $prg= basename($0);

# all n seconds the client reports logged_in users to gosa-si-server
my $trigger_logged_in_users_report_delay = 600;

# all n seconds the client reports messages seen by user
my $trigger_seen_messages_delay = 30;

# directory where all log files from installation are stored
my $fai_log_dir = "/var/log/fai"; 

%cfg_defaults = (
"General" =>
    {"log-file"           => [\$log_file, "/var/log/gosa-si/gosa-si.log"],
    "pid-file"            => [\$pid_file, "/var/run/gosa-si/gosa-si-client.pid"],
    "opts-file"            => [\$opts_file, "/var/run/gosa-si/gosa-si-client.opts"],
    },
"Client" => 
    {"port"        => [\$client_port, "20083"],
     "ip"          => [\$client_ip, "0.0.0.0"],
     "mac-address" => [\$client_mac_address, "00:00:00:00:00:00"],
     "server-domain"      => [\$server_domain, ""],
     "ldap"               => [\$ldap_enabled, 1],
     "ldap-config"        => [\$ldap_config, "/etc/ldap/ldap.conf"],
     "pam-config"         => [\$pam_config, "/etc/pam_ldap.conf"],
     "nss-config"         => [\$nss_config, "/etc/libnss-ldap.conf"],
     "fai-logpath"        => [\$fai_logpath, "/var/log/fai/fai.log"],
     "force-hostname"	  => [\$client_force_hostname, "false"],
     "system-com"	  => [\$system_com, "disabled"],
    },
"Server" => {
    "ip"          => [\$servers_string, "127.0.0.1"],
    "port"         => [\$server_port, "20081"],
    "key"          => [\$server_key, ""],
    "timeout"      => [\$server_timeout, 10],
    "key-lifetime" => [\$server_key_lifetime, 600],
    "dns-lookup"   => [\$opts_dnslookup, "true"],
    },

);


#=== FUNCTIONS = functions =====================================================

#############################
#
# @brief Display error message and/or help text.
#
# In correspondence to previous GetOptions
#
# @param $text - string to print as error message
# @param $help - set true, if you want to show usage help
#
sub usage
{
  my( $text, $help ) = @_;

  $text = undef if( 'h' eq $text );
  (defined $text) && print STDERR "\n$text\n";

  if( (defined $help && $help)
      || (!defined $help && !defined $text) )
{
    print STDERR << "EOF";

  usage: $0 [-hvf] [-c config]

   -h        : this (help) message
   -c <file> : config file (default: ${config})
   -x <cfg>  : dump configuration to stdout
             ( 1 = current, 2 = default )
   -f        : foreground (don't fork)
   -v        : be verbose (multiple to increase verbosity)
EOF
}
  print( "\n" );

  exit( -1 );
}

#############################
#
# @brief Manage gosa-si-client configuration.
#
# Will exit after successfull dump to stdout (type = 1 | 2)
#
# Dump type can be:
#   1: Current gosa-si-client configuration in config file (exit)
#   2: Default gosa-si-client configuration (exit)
#   3: Dump to logfile (no exit)
#
# @param int config type
#
sub dump_configuration {

  my( $cfg_type ) = @_;

  return if( ! defined $cfg_type );

  if(1==$cfg_type ) {
    print( "# Current gosa-si-client configuration\n" );
	} elsif (2==$cfg_type) {
    print( "# Default gosa-si-client configuration\n" );
	} elsif (3==$cfg_type) {
    daemon_log( "Dumping gosa-si-client configuration\n", 2 );
	} else {
    return;
	}

  foreach my $section (keys %cfg_defaults) {
    if( 3 != $cfg_type ) { 
      print( "\n[${section}]\n" ); 
	} else {
      daemon_log( "\n  [${section}]\n", 3 ); 
	}

    foreach my $param (sort( keys %{$cfg_defaults{ $section }})) {
      my $pinfo = $cfg_defaults{ $section }{ $param };
      my $value;
      if (1==$cfg_type) {
        if( defined( ${@$pinfo[ 0 ]} ) ) {
          $value = ${@$pinfo[ 0 ]};
          print( "$param=$value\n" );
				} else {
          print( "#${param}=\n" ); 
				}
			} elsif (2==$cfg_type) {
        $value = @{$pinfo}[ 1 ];
        if( defined( @$pinfo[ 1 ] ) ) {
          $value = @{$pinfo}[ 1 ];
          print( "$param=$value\n" );
				} else {
          print( "#${param}=\n" ); 
				}
			} elsif (3==$cfg_type) {
        if( defined(  ${@$pinfo[ 0 ]} ) ) {
          $value = ${@$pinfo[ 0 ]};
          daemon_log( "  $param=$value\n", 3 )
				}
			}
		}
	}


# We just exit at stdout dump
  if( 3 == $cfg_type ) { 
    daemon_log( "\n", 3 );
	} else {
    exit( 0 );
	}
}

#############################
#
# @brief When caching an interrupt remove file pid and stopping gosa-si
#
sub sig_int_handler {
	my ($signal) = @_;

	daemon_log("shutting down gosa-si-client", 1);

	# shtudown the client by telling the poe kernel
	$global_kernel->yield('shutdown');

	#removing the opts file
	unlink ('/var/run/gosa-si/gosa-si-client.opts');

	#removing the fifo for communication 
	unlink ($fai_com_fifo);

	#removing the pid
	$pid->remove or warn "Could not remove $pid_file\n";

  exit(0);
}
$SIG{INT} = \&sig_int_handler;

#===  FUNCTION  ================================================================
#         NAME:  logging
#   PARAMETERS:  level - string - default 'info' 
#                msg - string - 
#                facility - string - default 'LOG_DAEMON' 
#      RETURNS:  
#  DESCRIPTION: 
#===============================================================================
sub daemon_log {
# log into log_file
    my( $msg, $level ) = @_;
    if(not defined $msg) { return }
    if(not defined $level) { $level = 1 }
    if(defined $log_file){
		my $open_log_fh = sysopen(LOG_HANDLE, $log_file, O_WRONLY | O_CREAT | O_APPEND , 0440); 
		if(not $open_log_fh) {
			print STDERR "cannot open $log_file: $!";
			return;
		}	
		# check owner and group of log_file and update settings if necessary       
		my ($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks) = stat($log_file);
		if((not $uid eq $root_uid) || (not $gid eq $adm_gid)) {
			chown($root_uid, $adm_gid, $log_file);
		}

        chomp($msg);
        if($level <= $verbose){
            my ($seconds, $minutes, $hours, $monthday, $month,
                    $year, $weekday, $yearday, $sommertime) = localtime(time);
            $hours = $hours < 10 ? $hours = "0".$hours : $hours;
            $minutes = $minutes < 10 ? $minutes = "0".$minutes : $minutes;
            $seconds = $seconds < 10 ? $seconds = "0".$seconds : $seconds;
            my @monthnames = ("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
            $month = $monthnames[$month];
            $monthday = $monthday < 10 ? $monthday = "0".$monthday : $monthday;
            $year+=1900;

			# Microseconds since epoch
			my $microSeconds = sprintf("%.2f", &Time::HiRes::clock_gettime());
			$microSeconds =~ s/^\d*(.\d\d)$/$1/;


            my $log_msg = "$month $monthday $hours:$minutes:$seconds$microSeconds gosa-si-client $msg\n";
            print LOG_HANDLE $log_msg;
            if( $foreground ) { 
                print STDERR $log_msg;
            }
        }
        close( LOG_HANDLE );
    }
}


#===  FUNCTION  ================================================================
#         NAME:  get_mac 
#   PARAMETERS:  interface name (i.e. eth0)
#      RETURNS:  (mac address) 
#  DESCRIPTION:  Uses ioctl to get mac address directly from system.
#===============================================================================
sub get_mac {
	my $ifreq= shift;
	my $result;
	if ($ifreq && length($ifreq) > 0) { 
		if($ifreq eq "all") {
			if(defined($server_ip)) {
				$result = &get_local_mac_for_remote_ip($server_ip);
			} 
			elsif ($client_mac_address && length($client_mac_address) > 0 && !($client_mac_address eq "00:00:00:00:00:00")){
				$result = &client_mac_address;
			} 
			else {
				$result = "00:00:00:00:00:00";
			}
		} else {
			# A configured MAC Address should always override a guessed value
			if ($client_mac_address and length($client_mac_address) > 0 and not($client_mac_address eq "00:00:00:00:00:00")) {
				$result= $client_mac_address;
			}
			else {
        $result = Net::ARP::get_mac($ifreq);
			}
		}
	}
	return $result;
}



#===  FUNCTION  ================================================================
#         NAME:  get_local_mac_for_remote_ip
#   PARAMETERS:  none (takes server_ip from global variable)
#      RETURNS:  (ip address from interface that is used for communication) 
#  DESCRIPTION:  Uses ioctl to get routing table from system, checks which entry
#                matches (defaultroute last).
#===============================================================================
sub get_local_mac_for_remote_ip {
	my $server_ip= shift;
	my $result= "00:00:00:00:00:00";

	if($server_ip =~ /^[a-z][a-z0-9\.]+/i) {
		my $ip_address = inet_ntoa(scalar gethostbyname($server_ip));
		if(defined($ip_address) && $ip_address =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/) {
			# Write ip address to $server_ip variable
			$server_ip = $ip_address;
		}
	}

	if($server_ip =~ /^(\d\d?\d?\.){3}\d\d?\d?$/) {
		my $PROC_NET_ROUTE= ('/proc/net/route');

		open(my $PROC_NET, "<","$PROC_NET_ROUTE")
			or die "Could not open $PROC_NET_ROUTE";

		my @ifs = <$PROC_NET>;

		close($PROC_NET);

		# Eat header line
		shift @ifs;
		chomp @ifs;
		foreach my $line(@ifs) {
			my ($Iface,$Destination,$Gateway,$Flags,$RefCnt,$Use,$Metric,$Mask,$MTU,$Window,$IRTT)=split(/\s/, $line);
			my $destination;
			my $mask;
			my ($d,$c,$b,$a)=unpack('a2 a2 a2 a2', $Destination);
			$destination= sprintf("%d.%d.%d.%d", hex($a), hex($b), hex($c), hex($d));
			($d,$c,$b,$a)=unpack('a2 a2 a2 a2', $Mask);
			$mask= sprintf("%d.%d.%d.%d", hex($a), hex($b), hex($c), hex($d));
			if(new NetAddr::IP($server_ip)->within(new NetAddr::IP($destination, $mask))) {
				# destination matches route, save mac and exit
				$result= &get_mac($Iface);
				last;
			}
		}
	} else {
		daemon_log("get_local_mac_for_remote_ip was called with a non-ip parameter: $server_ip", 1);
	}
	return $result;
}


sub generate_hw_digest {
	my $hw_data;
	foreach my $line (split /\n/, `cat /proc/bus/pci/devices`) {
		$hw_data.= sprintf "%s", $line =~ /[^\s]+\s([^\s]+)\s.*/;
	}
        # linux-vserver has no /proc/bus/pci/devices 
	if ( !$hw_data ) { 
		foreach my $line (split /\n/, `ifconfig | grep HWaddr`) { 
			$hw_data.= sprintf "%s", $line =~ /[^\s]+\s([^\s]+)\s.*/; 
		} 
	} 
	return(md5_base64($hw_data));
}


sub create_ciphering {
    my ($passwd) = @_;
	if((!defined($passwd)) || length($passwd)==0) {
		$passwd = "";
	}
    $passwd = substr(md5_hex("$passwd") x 32, 0, 32);
    my $iv = substr(md5_hex('GONICUS GmbH'),0, 16);
    my $my_cipher = Crypt::Rijndael->new($passwd , Crypt::Rijndael::MODE_CBC());
    $my_cipher->set_iv($iv);
    return $my_cipher;
}


sub encrypt_msg {
    my ($msg, $key) = @_;
    my $my_cipher = &create_ciphering($key);
    my $len;
    {
	    use bytes;
	    $len= 16-length($msg)%16;
    }
    $msg = "\0"x($len).$msg;
    $msg = $my_cipher->encrypt($msg);
    chomp($msg = &encode_base64($msg));
    # there are no newlines allowed inside msg
    $msg=~ s/\n//g;
    return $msg;
}


sub decrypt_msg {

    my ($msg, $key) = @_ ;
    $msg = &decode_base64($msg);
    my $my_cipher = &create_ciphering($key);
    $msg = $my_cipher->decrypt($msg); 
    $msg =~ s/\0*//g;
    return $msg;
}


#===  FUNCTION  ================================================================
#         NAME:  send_msg_hash_to_target
#   PARAMETERS:  msg_hash - hash - xml_hash created with function create_xml_hash
#                PeerAddr string - socket address to send msg
#                PeerPort string - socket port, if not included in socket address
#      RETURNS:  nothing
#  DESCRIPTION:  ????
#===============================================================================
sub send_msg_hash_to_target {
    my ($msg_hash, $address, $encrypt_key) = @_ ;
    my $msg = &create_xml_string($msg_hash);
    my $header = @{$msg_hash->{'header'}}[0];
    my $error = &send_msg_to_target($msg, $address, $encrypt_key, $header);
    
    return $error;
}

sub _setREGISTERED {
	my $newStatus = shift;
	&daemon_log("DEBUG: set REGISTERED flag from '$REGISTERED' to '$newStatus'", 7);
	$REGISTERED = $newStatus;
	return;
}

sub send_msg_to_target {
    my ($msg, $address, $encrypt_key, $msg_header) = @_ ;
    my $error = 0;

    if( $msg_header ) { $msg_header = "'$msg_header'-"; }
    else { $msg_header = ""; }

    # Memorize own source address
    $msg =~ /<source>(\S+)<\/source>/;
    my $own_source_address = $1;

    # encrypt xml msg
    my $crypted_msg = &encrypt_msg($msg, $encrypt_key);

    # opensocket
    my $socket = &open_socket($address);
    if( !$socket ) {
        daemon_log("WARNING: cannot send ".$msg_header."msg to '$address', host not reachable", 3);
        if ($REGISTERED == 1) {
            &_setREGISTERED(0);        # if server is not available, cause reregistering
            daemon_log("INFO: cause reregistering at gosa-si-server", 5); 
            $global_kernel->post('client_session', 'register_at_gosa_si_server');

        }
        $error++;
    }
    
    # send xml msg
    if( $error == 0 ) {
        print $socket $crypted_msg.";$own_source_address\n";
        daemon_log("INFO: send ".$msg_header."msg to $address", 5);
        daemon_log("DEBUG: message:\n$msg", 9);
    }

    # close socket in any case
    if( $socket ) {
        close $socket;
    }

    return $error;
}


sub write_to_file {
    my ($string, $file) = @_;
    my $error = 0;

    if( not defined $file || not -f $file ) {
        &main::daemon_log("ERROR: gosa-si-client : check '-f file' failed: $file", 1);
        $error++;
    }
    if( not defined $string || 0 == length($string)) {
        &main::daemon_log("ERROR: gosa-si-client : empty string to write to file '$file'", 1);
        $error++;
    }
    
    if( $error == 0 ) {

        chomp($string);
    
        if (open(my $FILE, ">>", "$file")){
          print $FILE $string."\n";
          close($FILE);
        }
    }

    return;
}


sub open_socket {
    my ($PeerAddr, $PeerPort) = @_ ;
    if(defined($PeerPort)){
        $PeerAddr = $PeerAddr.":".$PeerPort;
    }
    my $socket;
    $socket = new IO::Socket::INET(PeerAddr => $PeerAddr,
            Porto => "tcp",
            Type => SOCK_STREAM,
            Timeout => 5,
            );
    if(not defined $socket) {
        return;
    }
    &daemon_log("DEBUG: open_socket: $PeerAddr", 7);
    return $socket;
}


#===  FUNCTION  ================================================================
#         NAME:  register_at_server
#   PARAMETERS:  
#      RETURNS:  
#  DESCRIPTION:  
#===============================================================================
sub register_at_gosa_si_server {
	my ($kernel) = $_[KERNEL];
	my $try_to_register = 0;

	if ($REGISTERED) {
		# Client is already registered, clear all other registration events
		$kernel->delay('register_at_gosa_si_server');
	} else {
		# Client is not registered, start registration process
		# Clear all other events and wait till registration was successful
		$kernel->delay('register_at_gosa_si_server');
		$kernel->delay('trigger_new_key');

		# Create new passwd and ciphering object for client-server communication
		$server_key = &create_passwd();

		my $events = join( ",", keys %{$event_hash} );
		while(1) {
			$try_to_register++;

			# after one complete round through all server, stop trying to register           
			if( $try_to_register > @servers )  { last; }

			# fetch first gosa-si-server from @servers
			# append shifted gosa-si-server at the end of @servers, so looking for servers never stop if
			# a registration never occured
			my $server = shift(@servers);
			push( @servers, $server );

			# Check if $server is a valid server address
			if(!(defined($server) && $server =~ m/^[0-9\.]*?:.*$/)) {
				&main::daemon_log("ERROR: Server with address '".defined($server)?$server:""."' is invalid!", 1);
				if (length(@servers) == 1) {
					&main::daemon_log("ERROR: No valid servers found!", 1);
					exit(1);
				}
			}

			# Check if our ip is resolvable - if not: don't try to register
			my $ip= defined($client_ip)?$client_ip:&get_local_ip_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
			my $dnsname= gethostbyaddr(inet_aton($ip), AF_INET);
			if(!defined($dnsname)) {
				if( defined($client_force_hostname) && $client_force_hostname eq "true") {
					$dnsname = `hostname`;
				} else {
					&write_to_file("goto-error-dns:$ip", $fai_logpath);
					&main::daemon_log("ERROR: ip is not resolvable, no registration possible. Write 'goto-error-dns:$ip' to $fai_logpath", 1);
					exit(1);
				}
			}

			# create registration msg
			my $local_ip = (defined($client_ip))?$client_ip:&get_local_ip_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
			my $local_mac = &get_local_mac_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
			my $register_hash = &create_xml_hash("here_i_am", $local_ip.":".$client_port, $server);
			&add_content2xml_hash($register_hash, "new_passwd", $server_key);
			&add_content2xml_hash($register_hash, "mac_address", $local_mac);
			&add_content2xml_hash($register_hash, "events", $events);
			&add_content2xml_hash($register_hash, "client_status", $client_status);
			&add_content2xml_hash($register_hash, "client_revision", $client_revision);
			&add_content2xml_hash($register_hash, "gotoHardwareChecksum", $gotoHardwareChecksum);
			&add_content2xml_hash($register_hash, "key_lifetime", $server_key_lifetime);

			# Add $HOSTNAME from ENV if force-hostname is set
			if( defined($client_force_hostname) && $client_force_hostname eq "true") {
				if(defined($ENV{HOSTNAME}) && length($ENV{HOSTNAME}) >0 ) {
					&add_content2xml_hash($register_hash, "force-hostname", $ENV{HOSTNAME});
				} else {
					&main::daemon_log("force-hostname was set to true, but no \$HOSTNAME was found in Environment!",0);
				}
			}

			# send xml hash to server with general server passwd
			my $res = &send_msg_hash_to_target($register_hash, $server, $default_server_key);

			# if delivery of registration msg succeed
			if($res eq "0") {
				# reset try_to_register
				$try_to_register = 0;

				# Set fixed client address and mac address
				$client_ip= (defined($client_ip))?$client_ip:&get_local_ip_for_remote_ip(sprintf("%s", $server =~ /^([0-9\.]*?):.*$/));
				$client_address= "$client_ip:$client_port";
				$client_mac_address = $local_mac;
				$client_dnsname = $dnsname;
				last;

			# delivery of registration msg failed	
			} else {
				# wait 1 sec until trying to register again
				sleep(1);
				next;
			}

		} # end of while

		if ( $try_to_register >= @servers )  {
			# One circle through all servers finished and no registration succeed
			&write_to_file("gosa-si-no-server-available", $fai_logpath);
		} else {
			# Delivery of registraion msg succeed, waiting for server response
			daemon_log("INFO: waiting for msg 'register_at_gosa_si_server'",5);
			# Clear old settings and set it again
			$kernel->delay('trigger_new_key');
			$kernel->delay_set('trigger_new_key', $server_key_lifetime);
		}

		# Set waiting time for 'register_at_gosa_si_server'-event
		$kernel->delay_set('register_at_gosa_si_server', $delay_set_time);
	}
	return;
}
    

sub check_key_and_xml_validity {
    my ($crypted_msg, $module_key) = @_;

    my $msg;
    my $msg_hash;
    eval{
        $msg = &decrypt_msg($crypted_msg, $module_key);
        &main::daemon_log("decrypted_msg: \n$msg", 9);

        $msg_hash = $xml->XMLin($msg, ForceArray=>1);

        ##############
        # check header
        my $header_l = $msg_hash->{'header'};
        if( 1 != @{$header_l} ) {
            die 'no or more headers specified';
        }
        my $header = @{$header_l}[0];
        if( 0 == length $header) {
            die 'header has length 0';
        }

        ##############
        # check source
        my $source_l = $msg_hash->{'source'};
        if( 1 != @{$source_l} ) {
            die 'no or more than 1 sources specified';
        }
        my $source = @{$source_l}[0];
        if( 0 == length $source) {
            die 'source has length 0';
        }
        unless( $source =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ) {
            die "source '$source' is neither a complete ip-address with port nor 'GOSA'";
        }
        
        ##############
        # check target  
        my $target_l = $msg_hash->{'target'};
        if( 1 != @{$target_l} ) {
            die 'no or more than 1 targets specified ';
        }
        my $target = @{$target_l}[0];
        if( 0 == length $target) {
            die 'target has length 0 ';
        }
        unless( $target =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ){
            die "source is neither a complete ip-address with port nor 'GOSA'";
        }
    };
    if($@) {
        &main::daemon_log("WARNING: do not understand the message or msg is not gosa-si envelope conform:", 5);
        &main::daemon_log("$@", 8);
        $msg = undef;
        $msg_hash = undef;
    }

    return ($msg, $msg_hash);
}


sub check_outgoing_xml_validity {
    my ($msg) = @_;

    my $msg_hash;
    eval{
        $msg_hash = $xml->XMLin($msg, ForceArray=>1);

        ##############
        # check header
        my $header_l = $msg_hash->{'header'};
        if( 1 != @{$header_l} ) {
            die 'no or more than one headers specified';
        }
        my $header = @{$header_l}[0];
        if( 0 == length $header) {
            die 'header has length 0';
        }

        ##############
        # check source
        my $source_l = $msg_hash->{'source'};
        if( 1 != @{$source_l} ) {
            die 'no or more than 1 sources specified';
        }
        my $source = @{$source_l}[0];
        if( 0 == length $source) {
            die 'source has length 0';
        }
        unless( $source =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ||
                $source =~ /^GOSA$/i ) {
            die "source '$source' is neither a complete ip-address with port";
        }
        
        ##############
        # check target  
        my $target_l = $msg_hash->{'target'};
        if( 1 != @{$target_l} ) {
            die "no or more than one targets specified";
        }
        foreach my $target (@$target_l) {
            if( 0 == length $target) {
                die "target has length 0";
            }
            unless( $target =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+$/ ) {
                die "target '$target' is not a complete ip-address with port or a valid target name";
            }
        }
    };
    if($@) {
        daemon_log("WARNING: outgoing msg is not gosa-si envelope conform", 5);
        daemon_log("$@ $msg", 8);
        $msg_hash = undef;
    }
    return ($msg_hash);
}


sub trigger_new_key {
    my ($kernel) = $_[KERNEL] ;   

    my $msg = "<xml><header>new_key</header><source>$client_address</source><target>$client_address</target></xml>";
    &send_msg_to_target($msg, $client_address, $server_key, 'new_key');

    $kernel->delay_set('trigger_new_key', $server_key_lifetime);
}


sub trigger_logged_in_users_report {
    my ($kernel) = $_[KERNEL] ;  

    # just do if client is registered already
    if( $REGISTERED ) {
        my $result = qx(/usr/bin/users);
		my @logged_in_user_list;
		if( defined $result ) {
			chomp($result);
			@logged_in_user_list = split(/\s/, $result);
		}
		
        system("echo 'CURRENTLY_LOGGED_IN ".join(" ", @logged_in_user_list)."' > /var/run/gosa-si/gosa-si-client.socket"); 
        $kernel->delay_set('trigger_logged_in_users_report', $trigger_logged_in_users_report_delay);
    } else {
        # try it in 10 sec again
        $kernel->delay_set('trigger_logged_in_users_report', 10);
    }
}

sub trigger_set_terminal_server
{
	# Function is defined in load_reporter.pm
	if (exists $event_hash->{set_terminal_server}) 
	{
		no strict 'refs';
		&{$event_hash->{set_terminal_server}."::set_terminal_server"};
	}
	else
	{
		&daemon_log("0 ERROR: load_reporter.pm needs function set_terminal_server to write terminal server load information to client. Processing aborted!", 1);
	}
	return;
}

sub trigger_seen_messages {
    my ($kernel) = $_[KERNEL] ;

    # Select all files under /tmp with prefix 'goto_notify'
    my $goto_dir = "/tmp";
    opendir(DIR, $goto_dir);
    my @goto_files = grep { /.+\.goto_notify$/ && -f "$goto_dir/$_" } readdir(DIR);
    closedir DIR;

    # Check if file has 'seen' tag
    foreach my $goto_file (@goto_files) {
        open(my $FILE, "$goto_dir/$goto_file");
        my @lines = <$FILE>;
        close($FILE);

        my $source;
        my $target;
        my $usr;
        my $subject;
        my $message;
        my $seen = 0;
        chomp(@lines);
        foreach my $line (@lines) {
            if ($line =~ /^source:([\S\s]*)$/) {
                $source = $1
            }
            if ($line =~ /^target:([\S\s]*)$/) {
                $target = $1;
            }
            if ($line =~ /^usr:([\S\s]*)$/) {
                $usr = $1;
            }
            if ($line =~ /^subject:([\S\s]*)$/) {
                $subject = $1;
            }
            if ($line =~ /^message:([\S\s]*)$/) {
                $message = $1;
            }
            if ($line =~ /^seen$/) {
                $seen++;	
            }
        }

        # Send 'confirm_usr_msg' back to msg-hosting server
        if ($seen) {
            my %data = ('usr'=>$usr, 'subject'=>$subject, 'message'=>$message);
            my $confirm_msg = &build_msg("confirm_usr_msg", $target, $source, \%data);
            my $send_error = &send_msg_to_target($confirm_msg, $server_address, $server_key);

            # Delete file
            if (not $send_error) {
                system("rm $goto_dir/$goto_file");
            }
        }
    }

    $kernel->delay_set('trigger_seen_messages', $trigger_seen_messages_delay);

    return;
}


sub generic_file_error {
    my ( $heap, $operation, $errno, $error_string, $wheel_id ) =
      @_[ HEAP, ARG0, ARG1, ARG2, ARG3 ];

    my $service = $heap->{services}->{$wheel_id};
    daemon_log("ERROR: '$service' watcher $operation error $errno: $error_string", 1);
    daemon_log("ERROR: shutting down '$service' file watcher", 1);

    delete $heap->{services}->{$wheel_id};
    delete $heap->{watchers}->{$wheel_id};
    return;
}


sub fai_fifo_got_record {
    my $file_record = $_[ARG0];
    my $header;
    my $content = "";
    daemon_log("DEBUG: fifo got record: $file_record", 7); 

    $file_record =~ /^(\S+)[ ]?([\s\S]+)?$/;
    if( defined $1 ) {
        $header = $1;
    } else {
        return;
    }

    if( defined $2 ) {
        $content = $2;
    }

    my $clmsg_hash = &create_xml_hash("CLMSG_$header", $client_address, $server_address, $content);
    &add_content2xml_hash($clmsg_hash, "macaddress", $client_mac_address);
    my $utc_ts = &main::get_utc_time(); 
    &add_content2xml_hash($clmsg_hash, "timestamp", $utc_ts);
    my $clmsg = &create_xml_string($clmsg_hash);
    &send_msg_to_target($clmsg, $server_address, $server_key, "CLMSG_$header");

    # if installation finished, save all log files 
    if ($file_record eq "TASKBEGIN finish") {
        &save_fai_log($fai_log_dir); 
    }

    return;
}


sub system_fifo_got_record {
	my ($kernel, $socket_com_record) = @_[KERNEL, ARG0];
	$socket_com_record =~ /^(\S+)\s?([\s\S]*)$/; 
	my $function = $1; 
	my $content = $2;

	if( exists $event_hash->{$function} ) 
	{
		# a event exists with the header as name
		daemon_log("INFO: found event '$function' at event-module '".$event_hash->{$function}."'", 5);
		no strict 'refs';
		my $answer = &{$event_hash->{$function}."::$function"}($content, $kernel);
		&post_processing_and_sending($answer)
	}
	else 
	{
		daemon_log("ERROR: Got input '$socket_com_record' from socket '$system_com_fifo'", 1);
		daemon_log("ERROR: No event '$function' found in event modules under '$event_dir'.", 1);
	}

#	# Sanity check of fifo record
#
#	# Create record message
#	my $lr_msg_hash = &create_xml_hash("load_report", $client_address, $server_address, $file_record);
#	&add_content2xml_hash($lr_msg_hash, "macaddress", $client_mac_address);
#    my $utc_ts = &main::get_utc_time();
#    &add_content2xml_hash($lr_msg_hash, "timestamp", $utc_ts);
#    my $lr_msg = &create_xml_string($lr_msg_hash);
#
#	# Report message to si-server
#    &send_msg_to_target($lr_msg, $server_address, $server_key, "load_report");
	
	return;
}


sub save_fai_log {
    my ($fai_log_dir) = @_ ;
    my $FAI_DIR;

	# Directory for log files after a softupdate
    my $log_dir = File::Spec->catdir($fai_log_dir, "localhost/last");

    if (not -d $log_dir) { 
		# Directory for log files after a new installation
		$log_dir = "/tmp/fai";
		if (not -d $log_dir) {
				daemon_log("ERROR: cannot open directory $log_dir", 1);
				return; 
		}
    }

    opendir($FAI_DIR, "$log_dir");
    my @log_files = readdir($FAI_DIR);
    closedir($FAI_DIR);   

    my @log_list;
    foreach my $log_file (@log_files) {
        if( $log_file eq "." || $log_file eq ".." ) { next; }

        my $log = "log_file:$log_file:";
        $log_file = File::Spec->catfile( $log_dir, $log_file );

        if (not -f $log_file) {
            daemon_log("ERROR: cannot read $log_file", 1);
            next;
        }

        open(my $FILE, "<","$log_file");
        my @lines = <$FILE> ;
        close ($FILE);
        my $log_string = join("", @lines); 
        $log .= &encode_base64($log_string);
        push(@log_list, $log); 
    }

    my $all_log_string = join("\n", @log_list); 
    my $msg_hash = &create_xml_hash("CLMSG_save_fai_log", $client_address, $server_address, $all_log_string);
    &add_content2xml_hash($msg_hash, "macaddress", $client_mac_address);
    my $msg = &create_xml_string($msg_hash);
    &send_msg_to_target($msg, $server_address, $server_key, "CLMSG_save_fai_log");

}


sub sig_handler {
	my ($kernel, $signal) = @_[KERNEL, ARG0] ;
	daemon_log("0 INFO got signal '$signal'", 1); 
	$kernel->sig_handled();
	return;
}


sub _start {
    my ($kernel, $heap) = @_[KERNEL, HEAP];
    $kernel->alias_set('client_session');
    $global_kernel = $kernel;       # this is used to throw events at each point of the skript
 
    $kernel->sig(USR1 => "sig_handler");

    # force a registration at a gosa-si-server
    $kernel->yield('register_at_gosa_si_server');
    
    # install all file watcher defined
    while( my($name, $file) = each %files_to_watch ) {
        my $watcher = POE::Wheel::FollowTail->new(
            Filename   => $file,
            InputEvent => $name."_record",
            ErrorEvent => "file_error",
            );
        $heap->{services}->{ $watcher->ID } = $name;
        $heap->{watchers}->{ $watcher->ID } = $watcher;
    }
    $kernel->yield('trigger_logged_in_users_report'); 
    $kernel->yield('trigger_seen_messages');
}


sub _default {
    daemon_log("ERROR: can not handle incoming msg with header '$_[ARG0]'", 1);
    return;
}


sub server_input {
    my ($kernel, $heap, $input, $wheel) = @_[KERNEL, HEAP, ARG0, ARG1];
    my $remote_ip = $heap->{'remote_ip'},
    my $error = 0;
    my $answer;
    
    daemon_log("INFO: Incoming msg from '$remote_ip'", 5);
    daemon_log("DEBUG: Incoming msg:\n$input\n", 9);

	# Cut of ip and port from msgs tail
	my ($encrypted_msg, $msg_source) = split(/;/, $input);

    my ($msg, $msg_hash) = &check_key_and_xml_validity($encrypted_msg, $server_key);
    if( (!$msg) || (!$msg_hash) ) {
        daemon_log("WARNING: Deciphering of incoming msg failed", 3);
        if($server_address =~ /$remote_ip/) {
            # Got a msg from gosa-si-server which can not be decrypted, the secrete is not up-to-date
            # cause a reregistering with a new secrete handshake
			daemon_log("ERROR: Message from gosa-si-server could not be understood, cause reregistering at server", 1);
			if ($REGISTERED) {
				daemon_log("INFO: Client has currently status registered so throw new registering event", 5);
				&_setREGISTERED(0);
				$kernel->post('client_session', 'register_at_gosa_si_server');
			} else {
				daemon_log("INFO: Client is currently within a registration process so wait for the next registration itteration", 5);
			}
        }
        $error++;
    }


    ######################
    # process incoming msg
    if( $error == 0 ) {
        my $header = @{$msg_hash->{header}}[0];
        my $source = @{$msg_hash->{source}}[0];

        if( exists $event_hash->{$header} ) {

            # a event exists with the header as name
            daemon_log("INFO: found event '$header' at event-module '".$event_hash->{$header}."'", 5);
            no strict 'refs';
            $answer = &{$event_hash->{$header}."::$header"}($msg, $msg_hash);
        }
        else {
            daemon_log("WARNING: no event '$header' found in event modules under $event_dir", 3);
        }
    }

    ########
    # answer
	&post_processing_and_sending($answer);

    return;
}

sub post_processing_and_sending
{
	my ($answer) = @_ ;

	# Do nothing if answer does not exists
	if (not defined $answer) { return; }

	# Check gosa-si envelope validity
	my $answer_hash = &check_outgoing_xml_validity($answer);

	# If answer is valid go ahead
	if( not defined $answer_hash ) { return; }
	
	# Sending
	$answer =~ /<header>(\S+)<\/header>/;
	&send_msg_to_target($answer, $server_address, $server_key, $1);
	
	return;
}

sub find_servers {
    # add gosa-si-server address from config file at first position of server list
    my $server_check_cfg = Config::IniFiles->new( -file => $config );

    # Parse servers string
    my @conf_servers = split(',', $servers_string);

    # Now search for fallback servers in the configuration
    foreach my $cur_server (@conf_servers) {
        # Remove spaces from the IP
        $cur_server =~ s/\s//g;

        my $ip = $cur_server;
        if(not $cur_server =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/) {
            my $ip_address = inet_ntoa(scalar gethostbyname($ip));
            if(defined($ip_address) && $ip_address =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/) {
                # Write ip address to $server_ip variable
                $ip = $ip_address;
            }
        }

        my $server_addr = sprintf("%s:%s", $ip, $server_port);
        if (not grep { $_ eq $server_addr } @servers) {
           push(@servers, $server_addr);
        }
    }

    my $servers_string = join(", ", @servers);
    daemon_log("INFO: found servers in configuration file: $servers_string", 1);

    # Last but not least search for fallback servers in the DNS
    if (defined($opts_dnslookup) and $opts_dnslookup eq "true") {
        my @tmp_servers;
        if ( !$server_domain) {
            # Try our DNS Searchlist
            my @domain_list = &get_dns_domains();
            my $tmp_domains;
            my $error_string;
            for my $domain (@domain_list) {
                chomp($domain);
                ($tmp_domains, $error_string) = &get_server_addresses($domain);
                if(@$tmp_domains) {
                    for my $tmp_server(@$tmp_domains) {
                        push @tmp_servers, $tmp_server;
                    }
                }
            }

            if (0 == @tmp_servers) {
                daemon_log("INFO: No servers found in DNS.", 1);
            }
            else {
                my $servers_string = join(", ", @tmp_servers);
                daemon_log("INFO: found servers in DNS: $servers_string", 1);
            }
        } else {
            @tmp_servers = &get_server_addresses($server_domain);
            if( 0 == @tmp_servers ) {
            daemon_log("INFO: No servers found in DNS for domain '$server_domain'",1);
            }
        }

        if ( 0 != @tmp_servers ) {
            foreach my $server_addr (@tmp_servers) {
                if (not grep { $_ eq $server_addr } @servers) {
                   push(@servers, $server_addr);
                }
            }
        }
    }

    if (0 == scalar(@servers)) {
        daemon_log("ERROR: No servers found in the configuration or DNS.", 1);
        exit(1);
    }

    # Define first server as server_ip
    $server_ip = $servers[0];

    # prepare variables
    if( inet_aton($server_ip) ){ $server_ip = inet_ntoa(inet_aton($server_ip)); }
    if (defined $server_ip && defined $server_port) {
        $server_address = $server_ip.":".$server_port;
    }
}


sub start_daemon {

	if( ! $foreground ) {
		chdir '/'                 or die "Can't chdir to /: $!";
		umask 0;
		open STDIN, '+>/dev/null'   or die "Can't read /dev/null: $!";
		open STDOUT, '+>&STDIN' or die "Can't write to /dev/null: $!";
		open STDERR, '+>&STDIN' or die "Can't write to /dev/null: $!";
		defined($pid = fork)   or die "Can't fork: $!";
		exit if $pid;
		setsid                    or die "Can't start a new session: $!";
	}
	return;
}

sub put_version {

	# parse head url and revision from svn
	$client_version =~ /^\$HeadURL: (\S+) \$:\$Rev: (\d+) \$$/;
	$client_headURL = defined $1 ? $1 : 'unknown' ;
	$client_revision = defined $2 ? $2 : 'unknown' ;
	if ($client_headURL =~ /\/tag\// || 
        $client_headURL =~ /\/branches\// ) {
    $client_status = "stable"; 
	} else {
    $client_status = "developmental" ;
	}
	return;
}

sub get_perms_admin {
	# Determine root uid and adm gid, used for creating log files
	$root_uid = getpwnam('root');
	$adm_gid = getgrnam('adm');
	if(not defined $adm_gid){
		$adm_gid = getgrnam('root');
	}
	return;
}

sub create_pid {
	# Create the PID object
	$pid = File::Pid->new({ file  => $pid_file });

	# Write the PID file
	$pid->write;

	return;
}

#
#==== MAIN = main ==============================================================
#
# Parse options and allow '-vvv'
Getopt::Long::Configure( 'bundling' );
GetOptions( 'v|verbose+' => \$verbose,
            'h|help' => \&usage,
            'c|config=s' => \$config,
            'x|dump-config=i' => \$dump_config,
            'f|foreground' => \$foreground)
  or usage( '', 1 );

# We may want to dump the default configuration
if( defined $dump_config ) {
  if($dump_config==1) {
	} elsif ($dump_config==2) {
    dump_configuration( $dump_config ); 
	} else {
    usage( "Dump configuration value has to be 1 or 2" );
	}
}

#  read and set config parameters
&read_configfile($config, %cfg_defaults);

# daemonize the program
&start_daemon($foreground);

# create pid file
&create_pid($pid, $pid_file);

# Determine root uid and adm gid, used for creating log files
&get_perms_admin($root_uid, $adm_gid);

# put version
&put_version($client_status_hash, $client_version, $client_version, $client_headURL, $client_status);

daemon_log(" ", 1);
daemon_log("$0 started!", 1);
daemon_log("INFO: status: $client_status", 1);
daemon_log("INFO: ".$client_status_hash->{$client_status}.": $client_revision", 1); 

# to be changed maybe not trace of it when running 
#system('rm -f /tmp/gosa_si_lock*gosa-si-client*');

# detect ip and mac address and complete host address
$client_address = $client_ip.":".$client_port;
my $network_interface= &get_interface_for_ip($client_ip);
$client_mac_address= &get_mac($network_interface);

daemon_log("INFO: ip address detected: $client_ip", 1);
daemon_log("INFO: $0 mac address detected: $client_mac_address", 1);


# import events
my ($error, $result, $tmp_hash) = &import_events($event_dir);
while (my ($module, $mod_event_hash) = each %$tmp_hash) {
    while (my ($event_name, $nothing) = each %$mod_event_hash) {
        $event_hash->{$event_name} = $module;
    }
}

foreach my $log_line (@$result) {
    if ($log_line =~ / succeed: /) {
        &main::daemon_log("0 DEBUG: $log_line", 7);
    } else {
        &main::daemon_log("0 ERROR: $log_line", 1);
    }
}


# compute hardware checksum
$gotoHardwareChecksum= &generate_hw_digest();
daemon_log("INFO: gotoHardwareChecksum detected: $gotoHardwareChecksum", 1);

# create socket for incoming xml messages
POE::Component::Server::TCP->new(
    Alias => 'gosa-si-client',
	Port => $client_port,
	ClientInput => \&server_input,
);
daemon_log("INFO: start socket for incoming xml messages at port '$client_port' ", 1);

$xml = new XML::Simple();
$default_server_key = $server_key;

# Open a new fifo for FAI messages to gosa-si-server
if (-p $fai_com_fifo) { unlink $fai_com_fifo }
POSIX::mkfifo("$fai_com_fifo", 0600);

# Find servers from config and DNS
&find_servers;

# Open a new fifo for system communication, 
if (-p $system_com_fifo) { unlink $system_com_fifo }
if ($system_com eq "enabled") 
{ 
	POSIX::mkfifo("$system_com_fifo", 0600); 
}

POE::Session->create(
	inline_states => {
		_start => \&_start,
		_default => \&_default,
		sig_handler => \&sig_handler,
		register_at_gosa_si_server => \&register_at_gosa_si_server,

		# trigger periodical tasks
		trigger_new_key => \&trigger_new_key,
		trigger_logged_in_users_report => \&trigger_logged_in_users_report,
		trigger_seen_messages => \&trigger_seen_messages,

		# trigger non periodical tasks
		trigger_set_terminal_server => \&trigger_set_terminal_server,

		# handle records from each defined file differently
		fai_fifo_record => \&fai_fifo_got_record,
		system_fifo_record => \&system_fifo_got_record,

		# handle file resets and errors the same way for each file
		file_reset => \&generic_file_reset,
		file_error => \&generic_file_error,
	}
);

POE::Kernel->run();
exit;

